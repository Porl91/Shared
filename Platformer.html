<!doctype html/>
<html>
	<head>
		<title>Platformer</title>
	</head>
	<body>
		<canvas id="scene"></canvas>
		<link rel="stylesheet" type="text/css" href="Content/CSS/Global.css"/>
		<script src="Geom/Vector2.js" type="text/javascript"></script>
		<script src="Geom/BoundingUnits/AABB.js" type="text/javascript"></script>
		<script src="Geom/LineSegment.js" type="text/javascript"></script>
		<script src="ViewModels/GameViewModel.js" type="text/javascript"></script>

		<script>
			var lineSegs = [];
			var points = [];
			var player;

			var keyboard;

			var Player = function(position, aabb) {
				this.Position = position;
				this.Velocity = new Vector2(0, 0);
				this.Acceleration = new Vector2(0, 0);
				this.AABB = aabb;
				this.Jumping = false;

				this.Update = function() {
					this.AABB.position = this.Position;

					if(keyboard.IsKeyDown(65)) {
						this.Velocity.x -= 5;
					} else {
						this.Velocity.x = 0;
					}

					if(keyboard.IsKeyDown(68)) {
						this.Velocity.x += 5;
					} else {
						this.Velocity.x = 0;
					}

					if(keyboard.IsKeyDown(32)) {
						this.HandleJumpAction();
					}

					this.Velocity = this.Velocity.Add(this.Acceleration);
					this.Acceleration = this.Acceleration.Add(new Vector2(0, 0.0981));

					// Test collisions

					this.Position = this.Position.Add(this.Velocity);
				};

				this.HandleJumpAction = function() {
					if(!this.Jumping) {
						this.Acceleration = new Vector2(0, -0.9);
						this.Velocity = new Vector2(this.Velocity.x, 0).Add(this.Acceleration);
						this.Jumping = true;
					}
				};

				this.Render = function(viewModel) {
					var x0 = (this.Position.x - this.AABB.halfWidth) | 0;
					var x1 = (this.Position.x + this.AABB.halfWidth) | 0;
					var y0 = (this.Position.y - this.AABB.halfHeight) | 0;
					var y1 = (this.Position.y + this.AABB.halfHeight) | 0;

					viewModel.context.beginPath();

					viewModel.context.moveTo(x0, y0);
					viewModel.context.lineTo(x1, y0);
					viewModel.context.moveTo(x1, y0);
					viewModel.context.lineTo(x1, y1);
					viewModel.context.moveTo(x1, y1);
					viewModel.context.lineTo(x0, y1);
					viewModel.context.moveTo(x0, y1);
					viewModel.context.lineTo(x0, y0);

					viewModel.context.stroke();
					viewModel.context.closePath();
				};
			};

			var Initialise = function(viewModel) {
				keyboard = new KeyboardStateManager();
				player = new Player(new Vector2(200, 200), new AABB(new Vector2(200, 200), 25, 40));

				GenerateTerrain();
			};

			var GenerateTerrain = function() {
				var xStart = 0;
				var yStart = Math.random() * 100 + 400 | 0;
				var maxPoints = Math.random() * 5 + 15 | 0;

				// Generate {maxPoints} connected lines for the platform
				// Find the midpoint between the endpoints of each line
				// Get the perpendicular vector to the line segment constructed from these endpoints
				// Normalise the line segment and multiply it by some random arc peak
				// Add this to the midpoint
				// Create a quadratic bezier curve with more granular points in between the initial points
				// Could possibly generate octaves of bezier curves to apply generative detail

				var previousPoint = new Vector2(xStart, yStart);

				points.push(new Vector2(0, window.innerHeight));
				for(var i = 1; i < 15; i++) {
					var currentPoint = new Vector2(150 * i + xStart, previousPoint.y + ((Math.random() - 0.5) * 100) | 0);
					CreateGranularPoints(previousPoint, currentPoint);
					previousPoint = currentPoint;
				}
				points.push(new Vector2(window.innerWidth, window.innerHeight));

				CreateLinesFromPoints();
			};

			var CreateGranularPoints = function(point1, point2) {
				var lineSegment = point2.Sub(point1);
				var perpLineSegNorm = lineSegment.Perp().Normalise();
				var curveHeight = (Math.random() * 2.0 - 1.5) * 40;
				var curvePeakPoint = point1.Add(lineSegment.Mid()).Add(perpLineSegNorm.Mult(curveHeight));

				points.push(point1);
				var numPointsRecip = 1.0 / (Math.random() * 5.0 + 10.0);
				for(var j = 0.0; j <= 1.0; j += numPointsRecip) {
					var lerp1 = point1.Lerp(curvePeakPoint, j);
					var lerp2 = point2.Lerp(curvePeakPoint, 1.0 - j);
					var lerp3 = lerp2.Lerp(lerp1, 1.0 - j); // LERPLERPLERPLERP

					points.push(lerp3);
				}
				points.push(point2);
			};

			var CreateLinesFromPoints = function() {
				var previousPoint = points[0];

				for(var i = 1; i < points.length; i++) {
					var currentPoint = points[i];
					lineSegs.push(new LineSegment(new Vector2(previousPoint.x, previousPoint.y), new Vector2(currentPoint.x, currentPoint.y)));
					previousPoint = currentPoint;
				}
			};

			var KeyboardStateManager = function() {
				var $keyboardStateManager = this;
				this.keyStates = [];

				window.onkeydown = window.onkeyup = function(e) {
					$keyboardStateManager.keyStates[e.keyCode] = e.type == 'keydown';
				};

				this.IsKeyDown = function(keyCode) {
					return this.keyStates[keyCode];
				};
			};

			var Update = function(viewModel) {
				player.Update();
			};

			var Render = function(viewModel) {
				viewModel.context.strokeStyle = "#fff";
				viewModel.context.lineWidth = 0;
				viewModel.context.fillStyle = "#060";

				viewModel.context.beginPath();
				viewModel.context.moveTo(lineSegs[0].Point1.x, lineSegs[0].Point1.y);

				for(var i = 1; i < lineSegs.length; i++) {
					viewModel.context.lineTo(lineSegs[i].Point2.x, lineSegs[i].Point2.y);
				}

				viewModel.context.closePath();
				viewModel.context.fill();

				viewModel.context.lineWidth = 1;
				player.Render(viewModel);
			};

			new GameViewModel({
				CanvasId: 'scene',
				Fps: 28,
				InitialiseCallback: Initialise,
				UpdateCallback: Update,
				RenderCallback: Render
			}).Begin();
		</script>
	</body>
</html>
