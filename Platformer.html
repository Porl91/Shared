<!doctype html/>
<html>
	<head>
		<title>Platformer</title>
	</head>
	<body>
		<canvas id="scene"></canvas>
		<link rel="stylesheet" type="text/css" href="Content/CSS/Global.css"/>
		<script src="Geom/Vector2.js" type="text/javascript"></script>
		<script src="Geom/BoundingUnits/AABB.js" type="text/javascript"></script>
		<script src="Geom/LineSegment.js" type="text/javascript"></script>
		<script src="ViewModels/GameViewModel.js" type="text/javascript"></script>
		
		<script>
			var lineSegs = [];
			var points = [];
			var player;
			
			var keyboard;
			
			var Player = function(position, aabb) {
				this.Position = position;
				this.Velocity = new Vector2(0, 0);
				this.Acceleration = new Vector2(0, 0);
				this.AABB = aabb;
				this.Jumping = false;
				
				this.Update = function() {
					this.AABB.position = this.Position;
					
					var newPos = new Vector2(this.Position.x, this.Position.y);
					
					if(keyboard.IsKeyDown(65)) {
						newPos.x -= 5;
					}
					if(keyboard.IsKeyDown(68)) {
						newPos.x += 5;
					}
					if(keyboard.IsKeyDown(32)) {
						this.HandleJumpAction();
					}
					
					this.Velocity = this.Velocity.Add(this.Acceleration);
					this.Acceleration = this.Acceleration.Add(new Vector2(0, 0.0981));
					newPos = newPos.Add(this.Velocity);
					
					// Test collisions
					this.Position = newPos;
				};
				
				this.HandleJumpAction = function() {
				};
				
				this.Render = function(viewModel) {
					var x0 = (this.Position.x - this.AABB.halfWidth) | 0;
					var x1 = (this.Position.x + this.AABB.halfWidth) | 0;
					var y0 = (this.Position.y - this.AABB.halfHeight) | 0;
					var y1 = (this.Position.y + this.AABB.halfHeight) | 0;
				
					viewModel.context.beginPath();
					
					viewModel.context.moveTo(x0, y0);
					viewModel.context.lineTo(x1, y0);
					viewModel.context.moveTo(x1, y0);
					viewModel.context.lineTo(x1, y1);
					viewModel.context.moveTo(x1, y1);
					viewModel.context.lineTo(x0, y1);
					viewModel.context.moveTo(x0, y1);
					viewModel.context.lineTo(x0, y0);
					
					viewModel.context.stroke();
					viewModel.context.closePath();
				};
			};
		
			var Initialise = function(viewModel) {
				keyboard = new KeyboardStateManager();
				player = new Player(new Vector2(200, 200), new AABB(new Vector2(200, 200), 25, 40));
			
				var xStart = 0;
				var yStart = Math.random() * 200 + 500 | 0;
				var maxPoints = Math.random() * 5 + 15 | 0;
				
				// Generate {maxPoints} connected lines for the platform
				// Find the midpoint between the endpoints of each line
				// Get the perpendicular vector to the line segment constructed from these endpoints
				// Normalise the line segment and multiply it by some random arc peak
				// Add this to the midpoint
				// Create a quadratic bezier curve with more granular points in between the initial points
				// Could possibly generate octaves of bezier curves to apply generative detail
				
				var previousPoint = new Vector2(xStart, yStart);
				
				for(var i = 1; i < 15; i++) {
					var currentPoint = new Vector2(150 * i + xStart, previousPoint.y + ((Math.random() - 0.5) * 100) | 0);
					CreateGranularPoints(previousPoint, currentPoint);
					previousPoint = currentPoint;
				}
				
				CreateLinesFromPoints();
			};
			
			var CreateGranularPoints = function(point1, point2) {
				var lineSegment = point2.Sub(point1);
				var perpLineSegNorm = lineSegment.Perp().Normalise();
				var curveHeight = (Math.random() * 2.0 - 1.5) * 40;
				var curvePeakPoint = point1.Add(lineSegment.Mid()).Add(perpLineSegNorm.Mult(curveHeight));
				
				var numPointsRecip = 1.0 / (Math.random() * 5.0 + 10.0);
				for(var j = 0.0; j <= 1.0; j += numPointsRecip) {
					var lerp1 = point1.Lerp(curvePeakPoint, j);
					var lerp2 = point2.Lerp(curvePeakPoint, 1.0 - j);
					var lerp3 = lerp2.Lerp(lerp1, 1.0 - j); // LERPLERPLERPLERP
					
					points.push(lerp3);
				}
			};
			
			var CreateLinesFromPoints = function() {
				var previousPoint = points[0];
				
				for(var i = 1; i < points.length; i++) {
					var currentPoint = points[i];
					lineSegs.push(new LineSegment(new Vector2(previousPoint.x, previousPoint.y), new Vector2(currentPoint.x, currentPoint.y)));
					previousPoint = currentPoint;
				}
			};
			
			var KeyboardStateManager = function() {
				var $keyboardStateManager = this;
				this.keyStates = [];
				
				window.onkeydown = window.onkeyup = function(e) {
					$keyboardStateManager.keyStates[e.keyCode] = e.type == 'keydown';
				};
				
				this.IsKeyDown = function(keyCode) {
					return this.keyStates[keyCode];
				};
			};
			
			var Update = function(viewModel) {
				player.Update();
			};
			
			var Render = function(viewModel) {
				viewModel.context.strokeStyle = "#fff";
				viewModel.context.lineWidth = 1;
				
				for(var i = 0; i < lineSegs.length; i++) {
					viewModel.context.beginPath();
					viewModel.context.moveTo(lineSegs[i].Point1.x, lineSegs[i].Point1.y);
					viewModel.context.lineTo(lineSegs[i].Point2.x, lineSegs[i].Point2.y);
					viewModel.context.stroke();
					viewModel.context.closePath();
				}
				
				player.Render(viewModel);
			};
		
			new GameViewModel({
				CanvasId: 'scene', 
				Fps: 28, 
				InitialiseCallback: Initialise, 
				UpdateCallback: Update, 
				RenderCallback: Render
			}).Begin();
		</script>
	</body>
</html>